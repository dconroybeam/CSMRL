---
title: "CSMRL Regret Model Script 20221112"
author: "Daniel Conroy-Beam"
date: '2022-11-12'
output: html_document
---
  
  
  
######Packages######
```{r}
library(ggplot2)
library(reshape2)
```






######Parameters######
```{r}

#Population size#
#Determines the starting and maximum population size of the model
popsize<-500



#UCB Constant#
#Controls degree of exploration for the UCB strategy and the UCB reciprocal
#Chosen based on parameter tuning
c<-.2
cRecip<-.2



#Thompson SD#
#Starting SD for Thompson sampling and Thompson Reciprocal
#Chosen based on parameter tuning
tSD<-.1
tSDRecip<-.1



#Epsilon#
#Probability of exploration for the Epsilon Greedy 
#and Epsilon Reciprocal investment strategy
#Chosen based on parameter tuning
e<-.15
eRegret<-.15



#Number of Observations#
#Total number of observation opportunities agents will have in mate search
#Expressed in blocks of 1,000 observations (for plotting)
blocks<-10



#Number of Learning Loops#
#Number of times which learning algorithms will be repeated
loops<-10



#Human Data#
#Load in the human data for parameterizing agents
hdata<-read.csv(file="Human Data/Processed Data/CAREER1 PROCESSED Data 01172020 104258.csv")



#Perceptual Noise#
#Noise in perception 
noisePerc<-.50



#Seed#
#Set seed for reproducibility
set.seed(20221112)

```






######Functions######
```{r}

#Agent generation#
agentGenerate<-function(popsize,sex,data){
  
  #Generate agents with trait and preferences by resampling from the human data
  agents<-apply(data[,c(10:41)],2,function(x) sample(x,popsize,replace=T))
  
  #Standardize ratings
  agents<-t(apply(agents,2,scale))
  
  #Create a copy of the human dataframe including just the required variables 
  hdata1<-data[,c(10:41)]
  
  #Calculates the correlation matrix for traits and preferences in the real data
  hdata1cor<-cor(hdata1)
  
  #Computes the Cholesky decomposition of this matrix
  #This will impose a realistic covariance matrix on the simulated data
  hdata1chol<-t(chol(hdata1cor))
  
  #Multiplies the scaled agent data by the Cholesky decomposition
  #This imposes approximately the correct covariance matrix
  agents<-t(hdata1chol %*% agents)
  
  #Add the mean of each variable to the simulated data to re-center data
  agents<-sapply(1:ncol(agents),function(x)
    (sd(hdata1[,x])*agents[,x])+mean(hdata1[,x]))
  
  
  #Truncate rated variables to the true mini and max found in the human data
  agents<-sapply(1:ncol(agents),function(x) 
    ifelse(agents[,x]>max(hdata1[,x]),max(hdata1[,x]),agents[,x]))
  
  agents<-sapply(1:ncol(agents),function(x) 
    ifelse(agents[,x]<min(hdata1[,x]),min(hdata1[,x]),agents[,x]))
  
  #Names variables appropriately
  colnames(agents)<-colnames(hdata1)
  
  return(as.data.frame(cbind(sex,agents)))
}



#Attraction calculation#
mvCalc<-function(ideal,traits){
  #ideal is ideal preferences
  #traits is actual trait values
  
  #Calculates Euclidean distance between preferences and traits
  #Transforms this distance such that positive values are more attractive 
  mv<-apply(traits,1,function(x) 
    (-1*(dist(rbind(ideal,x)))+sqrt(10^2*16))/sqrt(10^2*16))
  
  return(mv)
  
}



#Improved Sampling#
#A sample function that will return a single scalar if given it
resample <- function(x,...){if(length(x)==1) x else sample(x,...)} 

```






######Agent Generation######
```{r}

#Remove unnecessary columns from the human data
hdata<-hdata[,c(1,3:10,235:250,345:360)]

#Make sure there's no missing information
hdata<-hdata[complete.cases(hdata[,c(10:41)]),]

#Generate agents
males<-agentGenerate(popsize/2,1,hdata[hdata$sex==1,])
females<-agentGenerate(popsize/2,0,hdata[hdata$sex==0,])

#Give each agent a unique PIN
males$PIN<-sample(1:nrow(males),nrow(males),replace=F)
females$PIN<-sample(nrow(males):(nrow(males)+nrow(females)),
                    nrow(females),replace=F)

```






######Full Information Mate Choice######
```{r}
#Simulate mate choice with perfect information
#This will be the mate choices against which learning algorithms will be tested


###MV Calculation###

#Males
#Calculate the true mate value of each female to each male
maleAttMatrix<-t(apply(males,1,function(q) 
  mvCalc(as.numeric(q[2:17]),females[,c(18:33)])))

#Label these for ease of use
colnames(maleAttMatrix)<-females$PIN
rownames(maleAttMatrix)<-males$PIN

#Females
#Calculate the true mate value of each male to each female
femaleAttMatrix<-t(apply(females,1,function(q) 
  mvCalc(as.numeric(q[2:17]),males[,c(18:33)]))) 

#Label these for ease of use
colnames(femaleAttMatrix)<-males$PIN
rownames(femaleAttMatrix)<-females$PIN


#A blank dataframe for storing the paired couples
fullPairs<-matrix(,1,(ncol(males)+ncol(females)))
fullPairs<-as.data.frame(fullPairs)

#Name the fullPairs dataframe for cbinding
colnames(fullPairs)<-c(colnames(females),colnames(males))

#Invest in proportion to perceived MV
investPropsMale<-t(apply(maleAttMatrix,1,function(x) x*(10/sum(x))))
investPropsFemale<-t(apply(femaleAttMatrix,1,function(x) x*(10/sum(x))))

#Loop through 50 timesteps for courtship
for(a in 1:50){
  
  #How much investment each male agent received 
  #from each female agent in the previous timestep
  investProprMale<-t(investPropsFemale)
  
  #How much investment each female agent received 
  #from each male agent in the previous timestep
  investProprFemale<-t(investPropsMale)
  
  #Calculate how much investment each agent will send in this round.
  investPropsMale<-(investPropsMale*investProprMale)
  investPropsFemale<-(investPropsFemale*investProprFemale)
  
  #Rescale investment
  investPropsMale<-t(apply(investPropsMale,1,function(x) x*(10/sum(x))))
  investPropsFemale<-t(apply(investPropsFemale,1,function(x) x*(10/sum(x))))
  
  #Some models can produce NaNs. This just converts these to 0
  investPropsMale[is.nan(investPropsMale)]<-0
  investPropsFemale[is.nan(investPropsFemale)]<-0
}

#Determine which female each male has chosen
#Break ties randomly
mChoice<-data.frame("male"=1:nrow(males))
mChoice$choice<-apply(investPropsMale,1,function(x) 
  resample(which(x==max(x)),1))

#Determine which male each female has chosen
#Break ties randomly
fChoice<-data.frame("female"=1:nrow(females))
fChoice$choice<-apply(investPropsFemale,1,function(x) 
  resample(which(x==max(x)),1))

#Loop through females' choices
for(p in 1:nrow(fChoice)){
  #Determine the male chosen by the current focal female
  chosenMale<-fChoice$choice[p]
  
  #Determine the female chosen by the focal female's choice
  chosenFemale<-mChoice$choice[chosenMale]
  
  #If the chosen female is the focal female...
  if(chosenFemale==p){
    #Pair the male and female together
    fullPairs<-rbind(fullPairs,cbind(females[p,],males[chosenMale,]))
  }
  
  #Otherwise do nothing
  
}

#Remove the row of NAs from the fullPairs dataframe
fullPairs<-fullPairs[-1,]


#Determine Assortative Mating#

#Calculate average male and female prefs
malePrefs<-colMeans(males[,2:17])
femalePrefs<-colMeans(females[,2:17])

#Extract mated PINs
fullRels<-fullPairs[,c(34,68)]
colnames(fullRels)<-c("femalePIN","malePIN")

#Calculate male and female MVs
fullRels$femaleMV<-sapply(fullRels$femalePIN,function(x) 
  mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
)

fullRels$maleMV<-sapply(fullRels$malePIN,function(x) 
  mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
)

#Calculate correlation between male and female MVs
fullAssort<-cor(fullRels$femaleMV,fullRels$maleMV)

```






######Incomplete Information######
```{r}
#Simulating mate choice with noisy information


#Determine the amount of noise to add to MV perceptions
noise<-mean(c(var(c(maleAttMatrix)),
              var(c(femaleAttMatrix))))*
  (noisePerc/(1-noisePerc))

#Create a dataframe to store model results across loops
data<-data.frame("loop"=NA,
                 "model"=NA,
                 "obs"=NA,
                 "acc"=NA,
                 "r"=NA)
data<-data[-1,]

#Loop through learning loops
for(l in 1:loops){
  
  #Create a dataframe to store model results
  simResults<-data.frame("loop"=l,"model"=NA,
                         "obs"=NA,
                         "r"=NA,
                         "acc"=NA)
  
  #Learning Preparation#
  
  #Create matrices to store learned MV values
  epsilLearnMale<-matrix(1,nrow(males),nrow(females))
  epsilLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  ucbLearnMale<-matrix(1,nrow(males),nrow(females))
  ucbLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  thomLearnMale<-matrix(1,nrow(males),nrow(females))
  thomLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  thomSDMale<-matrix(tSD,nrow(males),nrow(females))
  thomSDFemale<-matrix(tSD,nrow(females),nrow(males))
  
  
  eRecipLearnMale<-matrix(1,nrow(males),nrow(females))
  eRecipLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  uRecipLearnMale<-matrix(1,nrow(males),nrow(females))
  uRecipLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  tRecipLearnMale<-matrix(1,nrow(males),nrow(females))
  tRecipLearnFemale<-matrix(1,nrow(females),nrow(males))
  
  tRecipSDMale<-matrix(tSDRecip,nrow(males),nrow(females))
  tRecipSDFemale<-matrix(tSDRecip,nrow(females),nrow(males))
  
  
  
  
  #Generate matrices to store the number of visits
  epsilInvestMale<-matrix(1,nrow(males),nrow(females))
  epsilInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  ucbInvestMale<-matrix(1,nrow(males),nrow(females))
  ucbInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  thomInvestMale<-matrix(1,nrow(males),nrow(females))
  thomInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  
  eRecipInvestMale<-matrix(1,nrow(males),nrow(females))
  eRecipInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  uRecipInvestMale<-matrix(1,nrow(males),nrow(females))
  uRecipInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  tRecipInvestMale<-matrix(1,nrow(males),nrow(females))
  tRecipInvestFemale<-matrix(1,nrow(females),nrow(males))
  
  
  
  #Generate matrices to track history of reciprocity for reciprocal models
  eRecipHistMale<-matrix(1,nrow(males),nrow(females))
  eRecipHistFemale<-matrix(1,nrow(females),nrow(males))
  
  uRecipHistMale<-matrix(1,nrow(males),nrow(females))
  uRecipHistFemale<-matrix(1,nrow(females),nrow(males))
  
  tRecipHistMale<-matrix(1,nrow(males),nrow(females))
  tRecipHistFemale<-matrix(1,nrow(females),nrow(males))
  
  
  
  ###Learning Trials#
  
  #Loop through blocks of 1,000 observations
  for(b in 1:blocks){
    
    #Loop through individual observations
    for(o in 1:1000){
      
      #Epsilon Greedy Learning#
      
      #Observe the most desirable partner 1-epsil% of the time...
      if(rbinom(1,1,e)==F){
        
        choiceMale<-cbind(1:nrow(males),
                          apply(epsilLearnMale,1,function(x) 
                            resample(which(x==max(x)),1)))
        choiceFemale<-cbind(1:nrow(females),
                            apply(epsilLearnFemale,1,function(x) 
                              resample(which(x==max(x)),1)))
        
      } else{
        
        #Otherwise, observe a random partner
        choiceMale<-cbind(1:nrow(males),
                          sample(1:nrow(females)))
        choiceFemale<-cbind(1:nrow(females),
                            sample(1:nrow(males)))
        
      }
      
      #Update learned MV with a noisy observation of chosen partners
      epsilLearnMale[choiceMale]<-(epsilLearnMale[choiceMale]*
                                     epsilInvestMale[choiceMale]+
                                     rnorm(nrow(choiceMale),
                                           maleAttMatrix[choiceMale],
                                           sqrt(noise)))/
        (epsilInvestMale[choiceMale]+1)
      
      epsilLearnFemale[choiceFemale]<-(epsilLearnFemale[choiceFemale]*
                                         epsilInvestFemale[choiceFemale]+
                                         rnorm(nrow(choiceFemale),
                                               femaleAttMatrix[choiceFemale],
                                               sqrt(noise)))/
        (epsilInvestFemale[choiceFemale]+1)
      
      #Update observation counts
      epsilInvestMale[choiceMale]<-epsilInvestMale[choiceMale]+1
      epsilInvestFemale[choiceFemale]<-epsilInvestFemale[choiceFemale]+1
      
      
      
      
      
      
      #UCB#
      
      #Calculate the constant that will be added to MV values
      #Increases the less frequently a potential mate is observed
      cm<-c*sqrt(log(rowSums(ucbInvestMale)[1])/ucbInvestMale)
      cf<-c*sqrt(log(rowSums(ucbInvestFemale)[1])/ucbInvestFemale)
      
      #Add constant to perceived MV
      ucbRewardMale<-ucbLearnMale+cm
      ucbRewardFemale<-ucbLearnFemale+cf
      
      #Choose the most rewarding option in light of this adjustment
      choiceMale<-cbind(1:nrow(males),
                        apply(ucbRewardMale,1,function(x)
                          resample(which(x==max(x)),1)))
      
      choiceFemale<-cbind(1:nrow(females),
                          apply(ucbRewardFemale,1,function(x)
                            resample(which(x==max(x)),1)))
      
      
      
      #Update learned MV with a noisy observation of chosen partners
      ucbLearnMale[choiceMale]<-(ucbLearnMale[choiceMale]*
                                   ucbInvestMale[choiceMale]+
                                   rnorm(nrow(choiceMale),
                                         maleAttMatrix[choiceMale],
                                         sqrt(noise)))/
        (ucbInvestMale[choiceMale]+1)
      
      ucbLearnFemale[choiceFemale]<-(ucbLearnFemale[choiceFemale]*
                                       ucbInvestFemale[choiceFemale]+
                                       rnorm(nrow(choiceFemale),
                                             femaleAttMatrix[choiceFemale],
                                             sqrt(noise)))/
        (ucbInvestFemale[choiceFemale]+1)
      
      
      
      #Update observation counts
      ucbInvestMale[choiceMale]<-ucbInvestMale[choiceMale]+1
      ucbInvestFemale[choiceFemale]<-ucbInvestFemale[choiceFemale]+1
      
      
      
      
      
      
      #Thompson Sampling#
      
      #Draw a random MV value from each agent's prior distribution
      thomDrawMale<-matrix(rnorm(length(thomLearnMale),
                                 thomLearnMale,
                                 thomSDMale),
                           nrow(maleAttMatrix),
                           ncol(maleAttMatrix))
      
      thomDrawFemale<-matrix(rnorm(length(thomLearnFemale),
                                   thomLearnFemale,
                                   thomSDFemale),
                             nrow(femaleAttMatrix),
                             ncol(femaleAttMatrix))
      
      #Choose the partner with the highest MV belief
      choiceMale<-cbind(1:nrow(males),
                        apply(thomDrawMale,1,function(x)
                          resample(which(x==max(x)),1)))
      choiceFemale<-cbind(1:nrow(females),
                          apply(thomDrawFemale,1,function(x)
                            resample(which(x==max(x)),1)))
      
      #Update the mean of agents' MV prior distributions
      thomLearnMale[choiceMale]<-(noise*thomLearnMale[choiceMale]+
                                    (thomSDMale[choiceMale]^2)*
                                    rnorm(nrow(choiceMale),
                                          maleAttMatrix[choiceMale],
                                          sqrt(noise)))/
        (noise+(thomSDMale[choiceMale]^2))
      
      thomLearnFemale[choiceFemale]<-(noise*thomLearnFemale[choiceFemale]+
                                        (thomSDFemale[choiceFemale]^2)*
                                        rnorm(nrow(choiceFemale),
                                              femaleAttMatrix[choiceFemale],
                                              sqrt(noise)))/
        (noise+(thomSDFemale[choiceFemale]^2))
      
      
      #And update the standard deviation of the prior distribution
      thomSDMale[choiceMale]<-sqrt((noise*thomSDMale[choiceMale]^2)/
                                     (noise+thomSDMale[choiceMale]^2))
      
      thomSDFemale[choiceFemale]<-sqrt((noise*thomSDFemale[choiceFemale]^2)/
                                         (noise+thomSDFemale[choiceFemale]^2))
      
      #Update observation counts
      thomInvestMale[choiceMale]<-thomInvestMale[choiceMale]+1
      thomInvestFemale[choiceFemale]<-thomInvestFemale[choiceFemale]+1
      
      
      
      
      
      
      #Reciprocal Epsilon Greedy#
      
      #With probability 1-epsilon...
      if(rbinom(1,1,(1-eRecip))){
        
        #Compute reward as the product of learned MV and history of reciprocity
        eRecipRewardMale<-eRecipLearnMale*eRecipHistMale
        eRecipRewardFemale<-eRecipLearnFemale*eRecipHistFemale
        
        #Choose the most rewarding option in light of this adjustment
        choiceMale<-cbind(1:nrow(males),
                          apply(eRecipRewardMale,1,function(x)
                            resample(which(x==max(x)),1)))
        
        choiceFemale<-cbind(1:nrow(females),
                            apply(eRecipRewardFemale,1,function(x)
                              resample(which(x==max(x)),1)))
        
      } else {
        
        #Otherwise, chose a mate to observe at random
        choiceMale<-cbind(1:nrow(males),
                          sample(1:nrow(females)))
        choiceFemale<-cbind(1:nrow(females),
                            sample(1:nrow(males)))
        
      }
      
      #Update learned MV with a noisy observation of chosen partners
      eRecipLearnMale[choiceMale]<-(eRecipLearnMale[choiceMale]*
                                      eRecipInvestMale[choiceMale]+
                                      rnorm(nrow(choiceMale),
                                            maleAttMatrix[choiceMale],
                                            sqrt(noise)))/
        (eRecipInvestMale[choiceMale]+1)
      
      eRecipLearnFemale[choiceFemale]<-(eRecipLearnFemale[choiceFemale]*
                                          eRecipInvestFemale[choiceFemale]+
                                          rnorm(nrow(choiceFemale),
                                                femaleAttMatrix[choiceFemale],
                                                sqrt(noise)))/
        (eRecipInvestFemale[choiceFemale]+1)
      
      #Update observation counts
      eRecipInvestMale[choiceMale]<-eRecipInvestMale[choiceMale]+1
      eRecipInvestFemale[choiceFemale]<-eRecipInvestFemale[choiceFemale]+1
      
      #Update reciprocity histories
      eRecipHistMale<-(t(eRecipInvestFemale)/eRecipInvestMale)
      eRecipHistFemale<-(t(eRecipInvestMale)/eRecipInvestFemale)
      
      
      
      
      
      
      #Reciprocal UCB#
      
      #Calculate the constant that will be added to MV values
      #Increases the less frequently a potential mate is observed
      cm<-cRecip*sqrt(log(rowSums(uRecipInvestMale)[1])/uRecipInvestMale)
      cf<-cRecip*sqrt(log(rowSums(uRecipInvestFemale)[1])/uRecipInvestFemale)
      
      #Add constant to perceived MV
      uRecipRewardMale<-uRecipLearnMale+cm
      uRecipRewardFemale<-uRecipLearnFemale+cf
      
      #Choose the most rewarding option, weighted by reciprocity
      choiceMale<-cbind(1:nrow(males),
                        apply(uRecipRewardMale*
                                uRecipHistMale,1,function(x)
                                  resample(which(x==max(x)),1)))
      
      choiceFemale<-cbind(1:nrow(females),
                          apply(uRecipRewardFemale*
                                  uRecipHistFemale,1,function(x)
                                    resample(which(x==max(x)),1)))
      
      #Update learned MV with a noisy observation of chosen partners
      uRecipLearnMale[choiceMale]<-(uRecipLearnMale[choiceMale]*
                                      uRecipInvestMale[choiceMale]+
                                      rnorm(nrow(choiceMale),
                                            maleAttMatrix[choiceMale],
                                            sqrt(noise)))/
        (uRecipInvestMale[choiceMale]+1)
      
      uRecipLearnFemale[choiceFemale]<-(uRecipLearnFemale[choiceFemale]*
                                          uRecipInvestFemale[choiceFemale]+
                                          rnorm(nrow(choiceFemale),
                                                femaleAttMatrix[choiceFemale],
                                                sqrt(noise)))/
        (uRecipInvestFemale[choiceFemale]+1)
      
      #Update observation counts
      uRecipInvestMale[choiceMale]<-uRecipInvestMale[choiceMale]+1
      uRecipInvestFemale[choiceFemale]<-uRecipInvestFemale[choiceFemale]+1
      
      #Update reciprocity histories
      uRecipHistMale<-(t(uRecipInvestFemale)/uRecipInvestMale)
      uRecipHistFemale<-(t(uRecipInvestMale)/uRecipInvestFemale)
      
      
      
      
      
      
      #Reciprocal Thompson Sampling#
      
      #Draw a random MV value from each agent's prior distribution
      tRecipDrawMale<-matrix(rnorm(length(tRecipLearnMale),
                                   tRecipLearnMale,
                                   tRecipSDMale),
                             nrow(maleAttMatrix),
                             ncol(maleAttMatrix))
      
      tRecipDrawFemale<-matrix(rnorm(length(tRecipLearnFemale),
                                     tRecipLearnFemale,
                                     tRecipSDFemale),
                               nrow(femaleAttMatrix),
                               ncol(femaleAttMatrix))
      
      #Choose the partner with the highest MV belief, weighted by reciprocity
      choiceMale<-cbind(1:nrow(males),
                        apply(tRecipDrawMale*tRecipHistMale,1,function(x) 
                          resample(which(x==max(x)),1)))
      
      choiceFemale<-cbind(1:nrow(females),
                          apply(tRecipDrawFemale*tRecipHistFemale,1,function(x) 
                            resample(which(x==max(x)),1)))
      
      #Update the mean of agents' MV prior distributions
      tRecipLearnMale[choiceMale]<-(noise*tRecipLearnMale[choiceMale]+
                                      (tRecipSDMale[choiceMale]^2)*
                                      rnorm(nrow(choiceMale),
                                            maleAttMatrix[choiceMale],
                                            sqrt(noise)))/
        (noise+(tRecipSDMale[choiceMale]^2))
      
      tRecipLearnFemale[choiceFemale]<-(noise*tRecipLearnFemale[choiceFemale]+
                                          (tRecipSDFemale[choiceFemale]^2)*
                                          rnorm(nrow(choiceFemale),
                                                femaleAttMatrix[choiceFemale],
                                                sqrt(noise)))/
        (noise+(tRecipSDFemale[choiceFemale]^2))
      
      #And update the standard deviation of the prior distribution
      tRecipSDMale[choiceMale]<-sqrt((noise*tRecipSDMale[choiceMale]^2)/
                                       (noise+tRecipSDMale[choiceMale]^2))
      
      tRecipSDFemale[choiceFemale]<-sqrt((noise*tRecipSDFemale[choiceFemale]^2)/
                                           (noise+tRecipSDFemale[choiceFemale]^2))
      
      #Update observation counts
      tRecipInvestMale[choiceMale]<-tRecipInvestMale[choiceMale]+1
      tRecipInvestFemale[choiceFemale]<-tRecipInvestFemale[choiceFemale]+1
      
      #Update reciprocity histories
      tRecipHistMale<-(t(tRecipInvestFemale)/tRecipInvestMale)
      tRecipHistFemale<-(t(tRecipInvestMale)/tRecipInvestFemale)
      
    }
    
    
    
    
    
    
    ###Mate Choice###
    
    #No Learning Mate Choice#
    
    #A blank dataframe for storing the paired couples
    nlPairs<-matrix(,1,(ncol(males)+ncol(females)))
    nlPairs<-as.data.frame(nlPairs)
    
    #Name the nlPairs dataframe for cbinding
    colnames(nlPairs)<-c(colnames(females),colnames(males))
    
    #Set MV perceptions equal to one random observation
    nlMaleAttMatrix<-matrix(rnorm(length(maleAttMatrix),
                                  maleAttMatrix,
                                  sqrt(noise)),
                            nrow(maleAttMatrix),
                            ncol(maleAttMatrix))
    
    nlFemaleAttMatrix<-matrix(rnorm(length(femaleAttMatrix),
                                    femaleAttMatrix,
                                    sqrt(noise)),
                              nrow(femaleAttMatrix),
                              ncol(femaleAttMatrix))
    
    #Invest in proportion to observed MV
    investPropsMale<-t(apply(nlMaleAttMatrix,1,function(x)
      x*(10/sum(x))))
    
    investPropsFemale<-t(apply(nlFemaleAttMatrix,1,function(x)
      x*(10/sum(x))))
    
    #Loop through 50 timesteps for courtship
    for(a in 1:50){
      
      #How much investment each male agent received
      #from each female agent in the previous timestep
      investProprMale<-t(investPropsFemale)
      
      #How much investment each female agent received
      #from each male agent in the previous timestep
      investProprFemale<-t(investPropsMale)
      
      #Calculate how much investment each agent will send in this round.
      investPropsMale<-(investPropsMale*investProprMale)
      investPropsFemale<-(investPropsFemale*investProprFemale)
      
      #Rescale investment
      investPropsMale<-t(apply(investPropsMale,1,function(x)
        x*(10/sum(x))))
      
      investPropsFemale<-t(apply(investPropsFemale,1,function(x)
        x*(10/sum(x))))
      
      #Some models can produce NaNs. This just converts these to 0
      investPropsMale[is.nan(investPropsMale)]<-0
      investPropsFemale[is.nan(investPropsFemale)]<-0
      
    }
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(investPropsMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(investPropsFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        nlPairs<-rbind(nlPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the first row of NAs
    nlPairs<-nlPairs[-1,]
    
    #Extract mated PINs
    nlBlockRels<-nlPairs[,c(34,68)]
    colnames(nlBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    nlBlockRels$femaleMV<-sapply(nlBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    nlBlockRels$maleMV<-sapply(nlBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    #If there are enough pairs to compute a correlation...
    if(nrow(nlBlockRels)>2){
      
      #Compute and save that correlation
      nlAssort<-cor(nlBlockRels$femaleMV,nlBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      nlAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(nlBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      nlAcc<-fullRels$malePIN==nlBlockRels$malePIN[
        match(fullRels$femalePIN,nlBlockRels$femalePIN)]
      nlAcc[is.na(nlAcc)]<-0
      nlAcc<-mean(nlAcc)
      
    } else{
      
      #Otherwise just set it to 0
      nlAcc<-0
    }
    
    
    #Add results to complete results dataframe
    nlResults<-data.frame("loop"=l,
                             "model"="nl",
                             "obs"=b*1000,
                             "r"=nlAssort,
                             "acc"=nlAcc)
    
    simResults<-rbind(simResults,
                      nlResults)
    
    
    
    
    
    
    #Epsilon Greedy Mate Choice#
    
    #A blank dataframe for storing the paired couples
    epsilPairs<-matrix(,1,(ncol(males)+ncol(females)))
    epsilPairs<-as.data.frame(epsilPairs)
    
    #Name the epsilPairs dataframe for cbinding
    colnames(epsilPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(epsilInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(epsilInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        epsilPairs<-rbind(epsilPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the epsilPairs dataframe
    epsilPairs<-epsilPairs[-1,]
    
    #Extract mated PINs
    epsilBlockRels<-epsilPairs[,c(34,68)]
    colnames(epsilBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    epsilBlockRels$femaleMV<-sapply(epsilBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    epsilBlockRels$maleMV<-sapply(epsilBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(epsilBlockRels)>2){
      
      #Compute and save that correlation
      epsilAssort<-cor(epsilBlockRels$femaleMV,epsilBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      epsilAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(epsilBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      epsilAcc<-fullRels$malePIN==epsilBlockRels$malePIN[
        match(fullRels$femalePIN,epsilBlockRels$femalePIN)]
      epsilAcc[is.na(epsilAcc)]<-0
      epsilAcc<-mean(epsilAcc)
      
    } else{
      
      #Otherwise just set it to 0
      epsilAcc<-0
    }
    
    
    #Add results to complete results dataframe
    epsilResults<-data.frame("loop"=l,
                             "model"="epsil",
                             "obs"=b*1000,
                             "r"=epsilAssort,
                             "acc"=epsilAcc)
    
    simResults<-rbind(simResults,
                      epsilResults)
    
    
    
    
    
    
    #UCB Mate Choice#
    
    #A blank dataframe for storing the paired couples
    ucbPairs<-matrix(,1,(ncol(males)+ncol(females)))
    ucbPairs<-as.data.frame(ucbPairs)
    
    #Name the ucbPairs dataframe for cbinding
    colnames(ucbPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(ucbInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(ucbInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        ucbPairs<-rbind(ucbPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the ucbPairs dataframe
    ucbPairs<-ucbPairs[-1,]
    
    #Extract mated PINs
    ucbBlockRels<-ucbPairs[,c(34,68)]
    colnames(ucbBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    ucbBlockRels$femaleMV<-sapply(ucbBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    ucbBlockRels$maleMV<-sapply(ucbBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(ucbBlockRels)>2){
      
      #Compute and save that correlation
      ucbAssort<-cor(ucbBlockRels$femaleMV,ucbBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      ucbAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(ucbBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      ucbAcc<-fullRels$malePIN==ucbBlockRels$malePIN[
        match(fullRels$femalePIN,ucbBlockRels$femalePIN)]
      ucbAcc[is.na(ucbAcc)]<-0
      ucbAcc<-mean(ucbAcc)
      
    } else{
      
      #Otherwise just set it to 0
      ucbAcc<-0
    }
    
    
    #Add results to complete results dataframe
    ucbResults<-data.frame("loop"=l,
                           "model"="ucb",
                           "obs"=b*1000,
                           "r"=ucbAssort,
                           "acc"=ucbAcc)
    
    simResults<-rbind(simResults,
                      ucbResults)
    
    
    
    
    
    #Thompson Mate Choice#
    
    #A blank dataframe for storing the paired couples
    thomPairs<-matrix(,1,(ncol(males)+ncol(females)))
    thomPairs<-as.data.frame(thomPairs)
    
    #Name the thomPairs dataframe for cbinding
    colnames(thomPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(thomInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(thomInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        thomPairs<-rbind(thomPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the thomPairs dataframe
    thomPairs<-thomPairs[-1,]
    
    #Extract mated PINs
    thomBlockRels<-thomPairs[,c(34,68)]
    colnames(thomBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    thomBlockRels$femaleMV<-sapply(thomBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    thomBlockRels$maleMV<-sapply(thomBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(thomBlockRels)>2){
      
      #Compute and save that correlation
      thomAssort<-cor(thomBlockRels$femaleMV,thomBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      thomAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(thomBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      thomAcc<-fullRels$malePIN==thomBlockRels$malePIN[
        match(fullRels$femalePIN,thomBlockRels$femalePIN)]
      thomAcc[is.na(thomAcc)]<-0
      thomAcc<-mean(thomAcc)
      
    } else{
      
      #Otherwise just set it to 0
      thomAcc<-0
    }
    
    
    #Add results to complete results dataframe
    thomResults<-data.frame("loop"=l,
                            "model"="thom",
                            "obs"=b*1000,
                            "r"=thomAssort,
                            "acc"=thomAcc)
    
    simResults<-rbind(simResults,
                      thomResults)
    
    
    
    
    
    
    #Reciprocal Epsilon Greedy Mate Choice#
    
    #A blank dataframe for storing the paired couples
    eRecipPairs<-matrix(,1,(ncol(males)+ncol(females)))
    eRecipPairs<-as.data.frame(eRecipPairs)
    
    #Name the eRecipPairs dataframe for cbinding
    colnames(eRecipPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(eRecipInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(eRecipInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        eRecipPairs<-rbind(eRecipPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the eRecipPairs dataframe
    eRecipPairs<-eRecipPairs[-1,]
    
    #Extract mated PINs
    eRecipBlockRels<-eRecipPairs[,c(34,68)]
    colnames(eRecipBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    eRecipBlockRels$femaleMV<-sapply(eRecipBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    eRecipBlockRels$maleMV<-sapply(eRecipBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(eRecipBlockRels)>2){
      
      #Compute and save that correlation
      eRecipAssort<-cor(eRecipBlockRels$femaleMV,eRecipBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      eRecipAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(eRecipBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      eRecipAcc<-fullRels$malePIN==eRecipBlockRels$malePIN[
        match(fullRels$femalePIN,eRecipBlockRels$femalePIN)]
      eRecipAcc[is.na(eRecipAcc)]<-0
      eRecipAcc<-mean(eRecipAcc)
      
    } else{
      
      #Otherwise just set it to 0
      eRecipAcc<-0
    }
    
    
    #Add results to complete results dataframe
    eRecipResults<-data.frame("loop"=l,
                              "model"="eRecip",
                              "obs"=b*1000,
                              "r"=eRecipAssort,
                              "acc"=eRecipAcc)
    
    simResults<-rbind(simResults,
                      eRecipResults)      
    
    
    
    
    
    
    #Reciprocal UCB Mate Choice#
    
    #A blank dataframe for storing the paired couples
    uRecipPairs<-matrix(,1,(ncol(males)+ncol(females)))
    uRecipPairs<-as.data.frame(uRecipPairs)
    
    #Name the uRecipPairs dataframe for cbinding
    colnames(uRecipPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(uRecipInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(uRecipInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        uRecipPairs<-rbind(uRecipPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the uRecipPairs dataframe
    uRecipPairs<-uRecipPairs[-1,]
    
    #Extract mated PINs
    uRecipBlockRels<-uRecipPairs[,c(34,68)]
    colnames(uRecipBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    uRecipBlockRels$femaleMV<-sapply(uRecipBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    uRecipBlockRels$maleMV<-sapply(uRecipBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(uRecipBlockRels)>2){
      
      #Compute and save that correlation
      uRecipAssort<-cor(uRecipBlockRels$femaleMV,uRecipBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      uRecipAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(uRecipBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      uRecipAcc<-fullRels$malePIN==uRecipBlockRels$malePIN[
        match(fullRels$femalePIN,uRecipBlockRels$femalePIN)]
      uRecipAcc[is.na(uRecipAcc)]<-0
      uRecipAcc<-mean(uRecipAcc)
      
    } else{
      
      #Otherwise just set it to 0
      uRecipAcc<-0
    }
    
    
    #Add results to complete results dataframe
    uRecipResults<-data.frame("loop"=l,
                              "model"="uRecip",
                              "obs"=b*1000,
                              "r"=uRecipAssort,
                              "acc"=uRecipAcc)
    
    simResults<-rbind(simResults,
                      uRecipResults)      
    
    
    
    
    
    
    #Reciprocal Thompson Mate Choice#
    
    #A blank dataframe for storing the paired couples
    tRecipPairs<-matrix(,1,(ncol(males)+ncol(females)))
    tRecipPairs<-as.data.frame(tRecipPairs)
    
    #Name the tRecipPairs dataframe for cbinding
    colnames(tRecipPairs)<-c(colnames(females),colnames(males))
    
    #Determine which female each male has chosen
    #Break ties randomly
    mChoice<-data.frame("male"=1:nrow(males))
    mChoice$choice<-apply(tRecipInvestMale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Determine which male each female has chosen
    #Break ties randomly
    fChoice<-data.frame("female"=1:nrow(females))
    fChoice$choice<-apply(tRecipInvestFemale,1,function(x)
      resample(which(x==max(x)),1))
    
    #Loop through females' choices
    for(p in 1:nrow(fChoice)){
      
      #Determine the male chosen by the current focal female
      chosenMale<-fChoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenFemale<-mChoice$choice[chosenMale]
      
      #If the chosen female is the focal female...
      if(chosenFemale==p){
        #Pair the male and female together
        tRecipPairs<-rbind(tRecipPairs,cbind(females[p,],males[chosenMale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the tRecipPairs dataframe
    tRecipPairs<-tRecipPairs[-1,]
    
    #Extract mated PINs
    tRecipBlockRels<-tRecipPairs[,c(34,68)]
    colnames(tRecipBlockRels)<-c("femalePIN","malePIN")
    
    #Calculate male and female MVs
    tRecipBlockRels$femaleMV<-sapply(tRecipBlockRels$femalePIN,function(x) 
      mvCalc(malePrefs,females[females$PIN==x,c(18:33)])
    )
    
    tRecipBlockRels$maleMV<-sapply(tRecipBlockRels$malePIN,function(x) 
      mvCalc(femalePrefs,males[males$PIN==x,c(18:33)])
    )
    
    
    #If there are enough pairs to compute a correlation...
    if(nrow(tRecipBlockRels)>2){
      
      #Compute and save that correlation
      tRecipAssort<-cor(tRecipBlockRels$femaleMV,tRecipBlockRels$maleMV)
      
    } else {
      
      #Otherwise just set it to 0
      tRecipAssort<-0
      
    }
    
    #If there are any matches at all...
    if(nrow(tRecipBlockRels)>0){
      
      #Compute accuracy of matches relative to full information
      tRecipAcc<-fullRels$malePIN==tRecipBlockRels$malePIN[
        match(fullRels$femalePIN,tRecipBlockRels$femalePIN)]
      tRecipAcc[is.na(tRecipAcc)]<-0
      tRecipAcc<-mean(tRecipAcc)
      
    } else{
      
      #Otherwise just set it to 0
      tRecipAcc<-0
    }
    
    
    #Add results to complete results dataframe
    tRecipResults<-data.frame("loop"=l,
                              "model"="tRecip",
                              "obs"=b*1000,
                              "r"=tRecipAssort,
                              "acc"=tRecipAcc)
    
    simResults<-rbind(simResults,
                      tRecipResults)
    
  }
  
  #Remove the row of NAs from the results dataframe
  simResults<-simResults[-1,]
  
  #Rbind this loop's data into the full dataframe
  data<-rbind(data,simResults)
  
}



```






######Analysis######
```{r}

#Create a dataframe for summarized results
data2<-data.frame("model"=rep(sort(unique(data$model)),
                              each=length(unique(data$obs))),
                  "obs"=rep(unique(data$obs),
                            length(unique(data$model))))

#Compute average accuracy across models and observation blocks
data2$acc<-c(tapply(data$acc,
                    list(data$obs,data$model),function(x)
                      mean(x)))

#Compute average assortative mating across models and observation blocks
data2$r<-c(tapply(data$r,
                  list(data$obs,data$model),function(x) 
                    mean(x)))

#Reorder model levels
data2$model<-factor(data2$model,
                    levels=c("nl",
                             "epsil",
                             "thom",
                             "ucb",
                             "eRecip",
                             "tRecip",
                             "uRecip"),
                    labels=c("No Learning",
                             "Epsilon Greedy",
                             "Thompson\nSampling",
                             "UCB",
                             "Epsilon\nReciprocity",
                             "Thompson\nReciprocity",
                             "UCB\nReciprocity"))

#Melt data for plotting
plotData<-melt(data2,id.vars=c("model","obs"))

#Plot average assortative mating and simulation accuracy across models and observations
regretPlot<-qplot(obs,
                  value,
                  color=variable,
                  data=plotData,
                  xlab="Number of Observations",
                  ylab="Average Value")+
  geom_line()+
  theme_grey(base_size=20)+
  scale_color_discrete(name="Outcome",
                       labels=c("Simulation\nAccuracy (%)",
                                "Assortative\nMating (r)"))+
  facet_wrap(~model,ncol=4)+
  geom_hline(yintercept=1,color="#F8766D",linetype="dashed",lwd=1)+
  geom_hline(yintercept=fullAssort,color="#00BFC4",linetype="dashed",lwd=1)


write.csv(data2,"Model Outputs/Regret Models/CSMRL Regret Results.csv",row.names=F)

ggsave("Figures/CSMRL Regret Model Results.tiff",plot=regretPlot,
       width=14,height=10,units="in",dpi=300)

```



